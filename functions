#!/bin/bash

gohome() {
  cd "${HOME}" && [[ $# > 0 ]] && cd "./${*}"
}

goatom() {
  cd "${HOME}/.atom" && [[ $# > 0 ]] && cd "./${*}"
}

godot() {
  cd "${HOME}/.dotfiles" && [[ $# > 0 ]] && cd "./${*}"
}

gowww() {
  cd "${HOME}/www" && [[ $# > 0 ]] && cd "./${*}"
}

goproj() {
  cd "${HOME}/projects" && [[ $# > 0 ]] && cd "./${*}"
}

git_status() {
  if [[ $# == 1 && $1 == '-S' ]]; then
    git status --short
  else
    git status
  fi
}

commit_push() {
  set -f

  git commit -m $1 && git push $2
}

function bar {
  echo "$BASH_SOURCE"
}

newCommand() {
  basename="`basename(${0})`"

  command_name=""
  target_directory="${DOTFILES_PATH}/.bin"

  if [[ $# == 0 ]]; then
    __ "
    NAME: ${basename} -- Create new shell command
    DESCRIPTION:
      The By default all of these output lines are sorted first by controlling terminal, then by process ID.
    usage: command_name [target_directory]
    options:
      tar
    "
    return 1
  fi
}

function press_enter() {
    # echo -en "\nPress Enter to continue"
    # read
    clear
}

take() {
  menu_items=(
      'Display free disk space'
      'Display free memory'
      )
  menu="\n\033[41mPROGRAME MENU\033[0m"
  count=0
  while [[ "x${menu_items[${count}]}" != "x" ]]; do
      menu="${menu}\n$((${count} + 1)) - ${menu_items[${count}]}"
      count=$(($count + 1))
  done
  menu+="\n\nPlease enter option # or enter 0 to exit\n"
  menu+="\n======== END ========\n"

  selection=''
  until [[ $selection == 0 ]]; do
      clear
      echo -e "$menu"
      read selection && echo

      case $selection in
          1 ) clear; (echo "" && df | less); read; press_enter;;
          2 ) clear; (echo "" && ls | less); read; press_enter;;
          0 ) return;;
          * ) press_enter;;
      esac
  done
}

foo() {
  number=$1
  shift

  case $number in
      1) echo "General errors" ;;
      2) echo "Misuse of shell builtins" ;;
      126) echo "Command is not an executable" ;;
      127) echo "Command not found" ;;
      128) echo "Invalid argument to exit" ;;
      '128+n') echo "Fatal error signal \"n\"" ;;
      130) echo "Script terminated" ;;
      255*) echo "Exit status out of range" ;;
      0) exit ;;
  esac
}

__() {
  echo -ne "$1" && return
}

flushdns() {
  (sudo dscacheutil -flushcache && sudo killall -HUP mDNSResponder && say -f in "Cache flushed")
}

search() {
  find $1 -name $2 -type $3;
  # find . -name "*.c" -type f -exec ls -l {} \;
}

reload_shell() {
  clear; exec $SHELL -l;
}

ver() {
  if [[ $# == 1 ]]; then
    $1 --version 2> /dev/null
  fi
}

gem_search() {
  gem search $* --details | (less | grep $*)
}

brew_search() {
  selection=''
  output=''

  output=`brew search --desc $*`
  until [[ $selection == 'q' ]]; do
    clear
    echo -e "\n${output}\n\n(END)\n\n" | grep $*
    # echo -ne "\n${output}\n\n(END)" | grep $*
    read -n 1 selection && echo

    case $selection in
        q ) clear; return;;
        * ) clear;;
    esac
  done
  # brew desc -s $* | (less | grep $*)
  # brew search $* -e brew info {} \;
}

# 1b 5b 46 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 63 6c 65 61 72 0d
# 1b 5b 46 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 72 65 6c 6f 61 64 5f 73 68 65 6c 6c 0d
