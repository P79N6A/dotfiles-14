#!/bin/bash


home() {
  cd "${HOME}" && [[ $# > 0 ]] && cd "./${*}"
}

atom() {
  cd "${HOME}/.atom" && [[ $# > 0 ]] && cd "./${*}"
}

dot() {
  cd "${HOME}/.dotfiles" && [[ $# > 0 ]] && cd "./${*}"
}

www() {
  cd "${HOME}/www" && [[ $# > 0 ]] && cd "./${*}"
}

proj() {
  cd "${HOME}/projects" && [[ $# > 0 ]] && cd "./${*}"
}

git_status() {
  if [[ $# == 1 && $1 == '-s' ]]; then
    git status --short
  else
    git status
  fi
}

commit_push() {
  remote_name=""
  branch_name=""
  message=""

  if [[ $# == 0 ]]; then
    ee "\nusage: message [remote] [branch]\n"
    return 1
  fi

  message="$1"; shift

  if [[ -n $1 ]]; then
    remote_name="$1"; shift
  fi

  if [[ -n $1 ]]; then
    branch_name="$1"; shift
  fi

  git commit -m $message && git push $remote_name $branch_name

  return
}

function bar {
  echo "$BASH_SOURCE"
}

newCommand() {
  basename="`basename(${0})`"

  command_name=""
  target_directory="${DOTFILES_PATH}/.bin"

  if [[ $# == 0 ]]; then
    ee "
NAME: ${basename} -- Create new shell command
DESCRIPTION:
  The By default all of these output lines are sorted first by controlling terminal, then by process ID.
USAGE: command_name [target_directory]
OPTIONS:
  tar
"
    return 1
  fi
}

function press_enter() {
    # echo -en "\nPress Enter to continue"
    # read
    clear
}

take() {
  menu_items=(
      'Display free disk space'
      'Display free memory'
      )
  menu="\n\033[41mPROGRAME MENU\033[0m"
  count=0
  while [[ "x${menu_items[${count}]}" != "x" ]]; do
      menu="${menu}\n$((${count} + 1)) - ${menu_items[${count}]}"
      count=$(($count + 1))
  done
  menu+="\n\nPlease enter option # or enter 0 to exit\n"
  menu+="\n======== END ========\n"

  selection=''
  until [[ $selection == 0 ]]; do
      clear
      echo -e "$menu"
      read selection && echo

      case $selection in
          1 ) clear; (echo "" && df | less); read; press_enter;;
          2 ) clear; (echo "" && ls | less); read; press_enter;;
          0 ) return;;
          * ) press_enter;;
      esac
  done
}

foo() {
  number=$1
  shift

  case $number in
      1) echo "General errors" ;;
      2) echo "Misuse of shell builtins" ;;
      126) echo "Command is not an executable" ;;
      127) echo "Command not found" ;;
      128) echo "Invalid argument to exit" ;;
      '128+n') echo "Fatal error signal \"n\"" ;;
      130) echo "Script terminated" ;;
      255*) echo "Exit status out of range" ;;
      0) exit ;;
  esac
}

flushdns() {
  (sudo dscacheutil -flushcache && sudo killall -HUP mDNSResponder && say -f in "Cache flushed")
}

search() {
  find $1 -name $2 -type $3;
  # find . -name "*.c" -type f -exec ls -l {} \;
}

reload_shell() {
  clear; exec $SHELL -l;
}

ver() {
  if [[ $# == 1 ]]; then
    $1 --version 2> /dev/null
  fi
}

brew_search() {
  basename="$FUNCNAME"
  search_for=""

  if [[ $# != 1 ]]; then
    ee "
NAME: $basename
USAGE
  $basename keyword

DESCRIPTION
  xxx
"; return 1
  fi

  search_for="$1"; shift

  ee "\n""======== REMOTE FORMULAS ========\n"

  brew desc -s $search_for

  ee ""

  return

  # selection=''
  # output=''
  #
  # output=`brew search --desc $*`
  # until [[ $selection == 'q' ]]; do
  #   clear
  #   echo -e "\n${output}\n\n(END)\n\n" | grep $*
  #   # echo -ne "\n${output}\n\n(END)" | grep $*
  #   read -n 1 selection && echo
  #
  #   case $selection in
  #       q ) clear; return;;
  #       * ) clear;;
  #   esac
  # done
  # brew desc -s $* | (less | grep $*)
  # brew search $* -e brew info {} \;
}

# 1b 5b 46 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 63 6c 65 61 72 0d
# 1b 5b 46 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 72 65 6c 6f 61 64 5f 73 68 65 6c 6c 0d

ee() {
  echo -e "$1"; return
}

gem_search() {
  basename="$FUNCNAME"
  search_for=""

  if [[ $# != 1 ]]; then
    ee "
NAME: $basename
USAGE
  $basename keyword

DESCRIPTION
  xxx
"; return 1
  fi

  search_for="$1"; shift

  gem search $search_for --details

  ee ""

  return
}
